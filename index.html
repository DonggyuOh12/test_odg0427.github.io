<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" 
        content="width=device-width, initial-scale=1.0,
                 maximum-scale=1.0,
                 user-scalable=no"/>
  <title>실시간 손가락 추적 (반응형 v2)</title>
  <!-- MediaPipe Hands 라이브러리 -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.min.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 20px;
    }

    /* 비디오와 캔버스를 겹쳐서 반응형으로 표시하기 위한 컨테이너 */
    .video-container {
      position: relative;
      width: 100%;
      max-width: 640px; /* 최대 폭 640px */
      margin: 0 auto;   /* 가운데 정렬 */
    }

    /* 실제 영상은 너비 100%, 높이는 비율에 맞춰 자동조절 */
    video {
      width: 100%;
      height: auto;
      display: block;
      background-color: #000;
      border-radius: 5px;
    }

    /* 추적 결과 표시용 캔버스도 같은 위치에 겹치게 (absolute) */
    #handCanvas {
      position: absolute;
      top: 0;
      left: 0;
      /* width/height를 100%로 -> 부모(video-container)의 크기만큼 자동 확장 */
      width: 100%;
      height: 100%;
      pointer-events: none; /* 터치나 클릭이 아래로 통과되게 함 */
    }

    .status-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-weight: bold;
    }
    .loader {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #3498db;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 10px;
      vertical-align: middle;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>실시간 손가락 추적</h1>

    <div class="video-container">
      <video id="video" autoplay playsinline></video>
      <canvas id="handCanvas"></canvas>

      <!-- 모델 로딩 표시 영역 -->
      <div id="statusIndicator" class="status-indicator">
        <span id="loadingIndicator" class="loader"></span>
        <span id="statusText">모델 로딩 중...</span>
      </div>
    </div>
  </div>

  <script>
    let video, handCanvas, handCtx;
    let hands, camera;

    document.addEventListener('DOMContentLoaded', async () => {
      video = document.getElementById('video');
      handCanvas = document.getElementById('handCanvas');
      handCtx = handCanvas.getContext('2d');

      try {
        await setupMediapipeHands();
        document.getElementById('statusText').textContent = '모델 로드 완료';
        setTimeout(() => {
          document.getElementById('statusIndicator').style.display = 'none';
        }, 1500);
      } catch (error) {
        console.error("MediaPipe 모델 로드 오류:", error);
        document.getElementById('statusText').textContent = '모델 로드 실패';
        document.getElementById('loadingIndicator').style.display = 'none';
      }
    });

    /********************************************************
     * MediaPipe Hands 초기화 및 카메라 시작
     *  - 성능 최적화를 위해 modelComplexity=0 (가장 빠름)
     *  - maxNumHands=1 한 손만 추적
     *  - 내부 해상도(고정): 640x480
     ********************************************************/
    async function setupMediapipeHands() {
      hands = new window.Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
        }
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,  // 0 = 빠른, 1 = 중간, 2 = 정확 but 느림
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });

      hands.onResults(onHandResults);

      camera = new window.Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,  // 내부 해상도(고정)
        height: 480
      });

      await camera.start();

      // 캔버스의 실제 픽셀 크기는 640x480으로 설정 (비디오와 동일)
      handCanvas.width = 640;
      handCanvas.height = 480;
    }

    /********************************************************
     * 손 인식 결과 처리 (렌더링)
     *  - 실제로는 640x480에 그리지만
     *  - CSS에서 width=100%로 맞춰서 화면에 표시
     ********************************************************/
    function onHandResults(results) {
      // 1) 내부 캔버스(640x480) 초기화
      handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

      // 2) 영상 그리기
      handCtx.drawImage(video, 0, 0, handCanvas.width, handCanvas.height);

      // 3) 손가락 랜드마크 표식
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (const landmarks of results.multiHandLandmarks) {
          // 연결선 (옵션: 꼭 필요한 경우에만)
          window.drawConnectors(handCtx, landmarks, window.HAND_CONNECTIONS, {
            color: '#FFFFFF',
            lineWidth: 2
          });
          // 관절 포인트
          window.drawLandmarks(handCtx, landmarks, {
            color: '#FF0000',
            lineWidth: 1,
            radius: 2
          });

          // 예: 검지 손가락 끝 (랜드마크 index: 8)에 큰 원
          const indexTip = landmarks[8];
          const x = indexTip.x * handCanvas.width;
          const y = indexTip.y * handCanvas.height;

          handCtx.beginPath();
          handCtx.arc(x, y, 8, 0, 2 * Math.PI);
          handCtx.fillStyle = 'red';
          handCtx.fill();
          handCtx.strokeStyle = 'white';
          handCtx.lineWidth = 2;
          handCtx.stroke();
        }
      }
    }
  </script>
</body>
</html>

